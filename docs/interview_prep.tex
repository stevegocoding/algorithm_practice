% UTF-8 encoding
% Compile with latex+dvipdfmx, pdflatex or xelatex
% XeLaTeX is recommanded
% Some Chinese fonts should be installed in your system (SimSun, SimHei, FangSong, KaiTi)
\documentclass[UTF8]{report}
\usepackage{ctex}
\usepackage{ccaption}
\usepackage{listings}
\usepackage{amsmath}

% Source Code Formatting
\lstset{ %
	language=C++,                	% choose the language of the code
	basicstyle=\small\ttfamily,     % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	frame=single,           		% adds a frame around the code
	tabsize=2,          			% sets default tabsize to 2 spaces
	captionpos=b,           		% sets the caption-position to bottom
	breaklines=true,        		% sets automatic line breaking
	breakatwhitespace=false,    	% sets if automatic breaks should only happen at whitespace
	escapeinside={\%*}{*)}        % if you want to add a comment within your code
}


\author{Guangfu Shi}
\title{算法总结}

\begin{document}

\chapter{排序算法}

\section{Quick Sort}

\subsection{性能}
\subsubsection{时间复杂度}

\begin{table}[ht]
\begin{center}
	
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{ | l | l |}     	

	\hline

	Average & Worst \\
	\cline{1-2}

	\(O(n \cdot \log{n})\) 	& 		\(O(n^2)\)  \\

	\hline

	\end{tabular}
\end{center}
\label{tab:quicksort_time_complexity}
\end{table}

\textbf{Worst case}:  In the most unbalanced case, a single Quicksort call involves \(O(n)\) work plus two recursive calls on lists of size \(0\) and \(n-1\), so the recurrence relation is: 
\begin{equation}
\begin{split} 
T(n)& = O(n) + T(0) + T(n-1) \\
	& = O(n) + T(n-1) \\
	& = O(n^2)
\end{split}
\end{equation}

\textbf{Average}: In the most balanced case, a single quicksort call involves \(O(n)\) work plus two recursive calls on lists of size \(n/2\), so the recurrence relation is: 
\begin{equation}
\begin{split} 
T(n)& = O(n) + 2T(\frac{n}{2}) \\
	& = O(n \log{n}) 
\end{split}
\end{equation}


\subsubsection{空间复杂度}
@TODO

\subsection{实现}

\lstinputlisting[caption=算法导论中的实现]{quicksort_clsr.cpp} 


\section{Merge Sort}


\subsection{实现}


\section{Heap Sort}

\subsection{性能}

\subsubsection{时间复杂度}

\begin{table}[ht]
\begin{center}
	
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{ | l | l |}     	

	\hline

	Average & Worst \\
	\cline{1-2}

	\(O(n \cdot \log{n})\) 	& 		\(O(n \cdot \log{n})\)  \\

	\hline

	\end{tabular}
\end{center}
\label{tab:quicksort_time_complexity}
\end{table}

\subsection{实现}

下面的代码是采用 "sift down" 来做heapify的实现。 heapify的过程是一个自底向上(bottom-up)过程：从最后一个父节点(start节点)开始，用"sift down"保持从这个节点开始后面的所有节点是个heap，然后向上移动这个(start)节点，也就是start减1, 直到0。

\lstinputlisting[caption=Heap Sort]{heapsort.cpp} 

下面的代码是采用 "sift up" 来做heapify的实现。 heapify2的过程是一个自顶向下(top-down)过程：从第一个子节点(start节点)开始，用"sift up"保持从这个节点开始前面的所有节点是个heap，然后向下移动这个(start)节点，也就是start加1, 直到count-1。

\lstinputlisting[caption=Heap Sort]{heapsort2.cpp}

"sift down"版本的heapify的时间复杂度是 \(O(n)\), 而"sift up"版本的heapify2的时间复杂度是 \(O(n\log{n})\)。 从直觉上说这个差别来自于 heapify2 是自顶向下，节点数增加深度递增，"sift up" 中swap的操作就增加。而第一个heapify是自底向上，深度递减，swap的操作也递减。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{搜索算法}


\section{Binary Search}

\subsection{实现}

\lstinputlisting[caption=Iterative Implementation]{bsearch_ite.cpp} 
\lstinputlisting[caption=Recursive Implementation]{bsearch_rec.cpp} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{数组相关问题}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{链表相关问题}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{二叉树相关问题}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}

